- [WHU-ACM-OJ 题意](#whu-acm-oj-题意)
  - [编写规范](#编写规范)
  - [5 Holding Animals (3pts)](#5-holding-animals-3pts)
  - [6 Language of Animals (3pts)](#6-language-of-animals-3pts)
  - [7 Feeding Animals I (1pts)](#7-feeding-animals-i-1pts)
  - [8 Feeding Animals II (3pts)](#8-feeding-animals-ii-3pts)
  - [10 Alternate Sum (3pts)](#10-alternate-sum-3pts)
  - [16 Cherry Blossom (1pts)](#16-cherry-blossom-1pts)
  - [20 Adjacent Difference (1pts)](#20-adjacent-difference-1pts)
  - [24 Exploration (3pts)](#24-exploration-3pts)
  - [38 Help (3pts)](#38-help-3pts)
  - [62 Linear World (5pts)](#62-linear-world-5pts)
  - [64 What Is Left (1pts)](#64-what-is-left-1pts)
  - [80 Game (1pts)](#80-game-1pts)
  - [96 Race (3pts)](#96-race-3pts)
  - [98 Dongfangxu&zap (1pts)](#98-dongfangxuzap-1pts)
  - [99 flirly (5pts)](#99-flirly-5pts)
  - [100 Forest (1pts)](#100-forest-1pts)
  - [103 Littleken (1pts)](#103-littleken-1pts)
  - [106 String's Puzzle (3pts)](#106-strings-puzzle-3pts)
  - [107 DNA (1pts)](#107-dna-1pts)
  - [201 Circle (5pts)](#201-circle-5pts)
  - [202 找不同 (3pts)](#202-找不同-3pts)
  - [203 找相同 (3pts)](#203-找相同-3pts)
  - [204 继续找相同 (5pts)](#204-继续找相同-5pts)
  - [209 Sherlock's Expression (1pts)](#209-sherlocks-expression-1pts)
  - [211 表达式的值 (3pts)](#211-表达式的值-3pts)
  - [314 3n+1数链问题 (1pts)](#314-3n1数链问题-1pts)
  - [419 无聊的游戏 (1pts)](#419-无聊的游戏-1pts)
  - [478 Sudo...ku (3pts)](#478-sudoku-3pts)
  - [支持作者](#支持作者)

# WHU-ACM-OJ 题意

## 编写规范

欢迎大家参与编辑, 或者[支持作者](#支持作者):

1. 保持题号升序, 在对应位置插入
2. 题目名称使用 h2 标题 (两个 #), 格式为 `("## %d %s (%dpts)", 题号, 题名, 分数)`
3. 记得更新目录 (Table of Contents), 目录格式参考[这里](https://github.com/ekalinin/github-markdown-toc.go#remote-files)或下文说明
4. 写明输入输出格式. 能让人在不看网站上漫长的英文题面的情况下, 直接开始 coding
5. 标注数据范围, 除非原题就没写
6. 如果题目难理解, 可以适当增加对样例的解释
7. **最好在自己 AC 了该题目的情况下编写, 以保证自己理解的题意正确; 或者题意有模糊/歧义的地方一定要标注出来**

目录格式: `("[%s](#%s)", 标题, 链接)`

其中标题是展示出来的内容, 应当和题目名称的 h2 标题保持一致.

链接是通过标题转换的, 大概规则是:

- 将空格替换为 `-`
- 删除 `(`, `)`, `?` 等符号
- 全部替换为小写字母

比如 `5 Holding Animals (3pts)` 对应的链接是 `5-holding-animals-3pts`

注意缩进, h2 标题的目录需要两个空格.

## 5 Holding Animals (3pts)

01 背包问题. 多组输入, 每组:

第一行一个整数 N 表示物品个数.

接下来 N 行每行两个整数 W[i], V[i], 分别表示物品 i 的体积和价值.

然后一行一个整数 M 表示背包容量.

问能装到背包里的最大物品价值总和是多少.

N <= 100

W[i], V[i] <= 10,000

M <= 100,000

## 6 Language of Animals (3pts)

问两个点之间的最短路. 只有一组输入.

**[输入格式]**

第一行两个整数 N, M, 分别表示点数和边数.

接下来 M 行每行两个整数 A[i], B[i], 表示这两个点之间有一条无向边 (长为 1).

然后一行一个整数 K, 表示接下来有 K 个询问.

接下来 K 行每行两个整数 X[i], Y[i], 问这两个点之间的最短路径上会经过多少个点.

**[输出格式]**

输出 K 行, 每行一个整数. 如果两个点不连通, 输出 -1

**[数据范围]**

2 <= N <= 200,000

1 <= M <= 300,000

K <= 20

## 7 Feeding Animals I (1pts)

8 个人要喂动物, 每个人喂每种动物要花费一定时间.

问喂饱动物花费的最小时间总和.

注意, 这个题很水, 可以认为: 同一时刻只有一个人在喂动物.

多组输入, 每组:

第一行一个整数 N, 表示动物种数.

接下来 8 行, 每行 N 个整数, 表示一个人喂这 N 种动物分别花费的时间.

对于每组输入, 输出一行, 一个整数.

1 <= N <= 10,000

每个人对于任意一种动物的喂食时间不会超过 10,000

## 8 Feeding Animals II (3pts)

还是喂动物, 一个人可以喂一部分动物, 并且一个人喂动物数量有上限.

问是否所有动物都能被喂.

多组输入, 每组:

第一行两个整数 M, N, 表示人的数量和动物的数量.

接下来 M 行, 每行 N 个整数, `mtx[i][j]` (即 m x n 的矩阵).

`mtx[i][j]` 为 1 表示第 i 个人可以喂第 j 个动物, 为 0 则不可以.

然后一行, 一个整数 K 表示一个人最多可以喂 K 个动物.

对于每组输入, 输出一行, `Yes` 表示所有动物能被喂, `No` 表示不能.

1 <= N, M <= 100

## 10 Alternate Sum (3pts)

计算题.

给定集合 S, 定义 F(S):

- 集合 S 的数字从大到小排序 a[0], a[1], a[2]...
- F(S) = a[0] - a[1] + a[2] - a[3] ...

即排序后偶数项的和减去奇数项的和

问 S 的所有的子集的 F(S) 的总和是多少, 答案对 2006 取余.

多组输入, 每组:

第一行一个整数 N, 表示集合大小

接下来 N 行, 每行一个整数

当 N 为 0 时输入停止. (而不是 EOF)

对于每组输入, 输出一行, 一个整数.

1 <= N <= 1000

S 内的数字的绝对值不超过 `1 << 16`

## 16 Cherry Blossom (1pts)

给定一堆点, 判断这些点是否上下对称的.

多组输入, 每组:

第一行一个整数 N, 表示点的数量.

之后 N 行, 每行两个整数 X[i], Y[i], 表示点的坐标.

对于每组输入, 输出一行, `YES` 或 `NO`

1 <= N <= 1000

点坐标的绝对值不会超过 `1 << 16`

## 20 Adjacent Difference (1pts)

水题, 求差分数组再排序输出即可, 输出格式略坑.

第一行一个整数 T, 表示有 T 组数据.

接下来每一组数据占两行:

第一行一个整数 N, 表示数组大小.

第二行 N 个整数, 表示这个数组.

对于每组数据, 输出两行:

第一行为 `Case %d:`, 从 1 开始

第二行为 N 个整数

注意: 相邻两组数据的输出之间要加一个空行, 最后一组数据后不应该有多余的空行.

N <= 1000

## 24 Exploration (3pts)

给定一棵树, 可以从任意点出发. 问访问树上所有节点最少走多少路.

多组输入, 第一行一个整数 T, 表示数据组数, 接下来每组:

第一行一个整数 N, 表示节点个数 (2 <= N <= 50,000)

接下来 N - 1 行, 每行三个整数 `u`, `v`, `l` 表示存在一条 `u` 到 `v` 的无向边, 长度为 `l`

保证输入为一棵树.

对于每组输入, 输出:

```
Case %d:
%d
```

第一个 `%d` 表示编号, 从 1 开始, 第二个 `%d` 表示最短总路径和.

两组输出之间需要用一个空行隔开.

## 38 Help (3pts)

房间的地上有一些钩子, 你有一根绳子, 你可以把绳子剪成任意长度的.

问能否使用绳子将所有的钩子都连接起来 —— 直接连接或间接连接都可以.

多组输入, 每一组:

第一行两个整数 N, L, 表示钩子的数量和绳子长度. (2 <= N <= 100, L <= 32767)

之后 N 行, 每行两个非负整数, 表示钩子的坐标, 不超过 32767

对于每组输入, 如果可以将所有钩子连接起来, 输出 `Success!` 反之输出 `Poor magicpig!`

注意, 输入的结束不是 EOF, 而是 N = 0, 且该行只会有一个整数 N. 见样例输入:

```
2 1
0 0
1 1
2 2
0 0
1 1
0
```

## 62 Linear World (5pts)

在一条数轴上, 两个人面对面前行, 一条狗在他们俩之间跑来跑去.

狗在碰到一个人后会改变方向, 跑向另外一个人, 狗会在两个人相遇的时候停下.

给定两人一狗的初始位置, 速度以及狗的方向, 问在直到两人相遇, 狗一共沿着初始方向跑了多远.

多组输入, 第一行一个整数 T, 接下来 T 组输入, 每一组:

第一行两个整数 A, U, 表示第一个人的位置和速度.

第二行两个整数 B, V, 表示第二个人的位置和速度.

第三行三个整数 C, P, D, 表示狗的位置, 速度和初始方向.

保证 D 为 1 或 -1, 1 表示往左跑, -1 表示往右跑. 

并且 *A < B, P > U, P > V* (斜体为推测, 原题面太迷了 `au and p>v, d=1 or d=-1`)

所有数据不超过 `1 << 16`

对于每组输入, 输出一行, 一个小数, 保留 3 位小数.

## 64 What Is Left (1pts)

水题, 数组元素去重.

多组输入, 每组:

第一行一个整数 N, 表示数组大小.

第二行 N 个整数, 表示这个数组.

对于每组数据, 输出一行, 至多 N 个整数: 为去重并排序 (非降) 后的数组.

N <= 50000

## 80 Game (1pts)

flymouse 和 snoopy 轮流选数, 每次从 `[1, 13]` 中任选一个. 当一个人选完后, 所有数到总和达到 N 时这个人获胜.

两个人都采取最佳策略, 并且 flymouse 先手, 问谁必胜.

多组输入, 第一行一个整数 T, 表示数据组数.

接下来 T 行, 每行一个整数, 表示 N.

对于每组输入, 输出 `flymouse wins the game!` 或 `snoopy wins the game!`

例如 N = 9 时, flymouse 先手直接选 9 即可获胜.

而 N = 14 时, 无论 flymouse 选多少, 接下来 snoopy 都可选数获胜.

1 < N < 1,000,000,000

## 96 Race (3pts)

一共有三个种族, 为 Man, Pig 和 Man&Pig

Man 称呼 Man 和 Man&Pig 为 M, 而称呼 Pig 为 P

Pig 称呼 Man 和 Man&Pig 为 P, 而称呼 Pig 为 M

Man&Pig 称呼 Man 和 Pig 为 M, 而称呼 Man&Pig 为 P

有多组输入, 每组:

第一行一个整数 N, 表示有 N 个个体 (N <= 100)

接下来 N 行每行是一个字符串, 且长度为 N

即有一个 N * N 的字符矩阵, 其中第 i 行第 j 列表示个体 i 称呼个体 j 的方式.

特殊地, 一个个体称呼自己为 S.

问这 N 个个体中分别有多少个 Man, Pig 和 Man&Pig.

如果局面是不可能的, 输出 `Impossible`

如果有多种可能性, 输出全部, 并且按照三元组 `(M, P, &)` 的升序输出.

格式为 `M=%d, P=%d, &=%d`

样例输入:

```
5
SMMMM
MSMMM
MMSMM
MMMSM
MMMMS
```

样例输出:

```
M=0, P=5, &=0
M=4, P=0, &=1
M=5, P=0, &=0
```

## 98 Dongfangxu&zap (1pts)

本身中文题面.

## 99 flirly (5pts)

本身中文题面

## 100 Forest (1pts)

本身中文题面.

## 103 Littleken (1pts)

本身中文题面.

## 106 String's Puzzle (3pts)

计算字符串的排名，字符串:

- 仅由大写字母构成
- 字符不重复出现

多组输入，每组:

第一行一个正整数 N (N <= 26)

第二行一个长度为 N 的字符串

对于每组输入，输出一行，一个整数，表示长度为 N 的字符串有多少个比输入的字符串小。

输入以 N = 0 结束，而不是 EOF

样例 ABC, 这是最小的，所以输出 0

样例 ABD, 长度为 3 的字符串中，只有 ABC 一个比它小，所以输出 1

## 107 DNA (1pts)

计算两个 DNA 序列的相似度.

具体算法为计算得分, 可以通过插入 `-` 以获得最高得分, 最高得分即相似度.

共有四种碱基, A, C, G, T, 得分关系如下:

|      |  A   |  C   |  G   |  T   |  -   |
| :--: | :--: | :--: | :--: | :--: | :--: |
|  A   |  5   |  -1  |  -2  |  -1  |  -3  |
|  C   |  -1  |  5   |  -3  |  -2  |  -4  |
|  G   |  -2  |  -3  |  5   |  -2  |  -2  |
|  T   |  -1  |  -2  |  -2  |  5   |  -1  |
|  -   |  -3  |  -4  |  -2  |  -1  | -inf |

比如:

```
AGTGATG
GTTAG
```

最高得分的插入方式为:

```
AGTGAT-G
-GT--TAG
```

得分为: `(-3)+5+5+(-2)+(-3)+5+(-3)+5=9`, 即这两段 DNA 序列的相似度为 9

注意: 如果两个序列不一样长, 必须通过插入 `-` 保持一样长; 并且 `-` 和 `-` 无法匹配, 所以表中得分为 -inf.

多组输入, 首先一个整数 T, 表示数据组数.

每组数据两行, 表示两个 DNA 序列. 每行内首先有一个整数, 表示长度, 然后有一个字符串, 表示 DNA 序列. 整数和字符串之间有一个空格, 且字符串仅包含 `AGCT`, 长度不超过 100

对于每组输入, 输出一行, 一个整数, 表示两个 DNA 序列的相似度.

## 201 Circle (5pts)

本身中文题面.

## 202 找不同 (3pts)

本身中文题面.

## 203 找相同 (3pts)

本身中文题面.

## 204 继续找相同 (5pts)

本身中文题面.

## 209 Sherlock's Expression (1pts)

给定一个数字序列 `a1, a2, a3, a4, ..., an`

其代表的表达式初始为 `a1/a2/a3/a4/.../an`，即用 `/` 连接

现在你可以在其中加入任意括号来改变运算顺序，问最终该表达式的结果是否可能为整数？

多组输入，每组占两行，第一行一个正整数 n，表示数量，第二行 n 个正整数，表示这个数字序列。

对于每组输入，输出 `Yes` 或 `No`

n 不超过 10,000 序列中的数字不超过 1,000,000

## 211 表达式的值 (3pts)

本身中文题面.

## 314 3n+1数链问题 (1pts)

本身中文题面.

## 419 无聊的游戏 (1pts)

本身中文题面。(模拟拉火车)

## 478 Sudo...ku (3pts)

解数独.

一组输入. 9 x 9 的矩阵, 0 表示空格.

输出 9 x 9 的矩阵即可.

## 支持作者

![支持作者](https://github.com/MMMMMMoSky/ImageHost/raw/master/pay_collect.png)
